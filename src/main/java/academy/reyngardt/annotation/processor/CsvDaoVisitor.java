package academy.reyngardt.annotation.processor;

import com.squareup.javapoet.*;
import com.sun.source.util.Trees;
import com.sun.tools.javac.code.Flags;
import com.sun.tools.javac.processing.JavacProcessingEnvironment;
import com.sun.tools.javac.tree.JCTree;
import com.sun.tools.javac.tree.TreeMaker;
import com.sun.tools.javac.tree.TreeTranslator;
import com.sun.tools.javac.util.Names;

import javax.annotation.processing.Filer;
import javax.annotation.processing.Messager;
import javax.annotation.processing.ProcessingEnvironment;
import javax.lang.model.element.Modifier;
import javax.lang.model.element.TypeElement;
import javax.lang.model.element.VariableElement;
import javax.lang.model.util.ElementScanner9;
import javax.tools.Diagnostic;
import javax.tools.JavaFileObject;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.Writer;
import java.lang.reflect.Method;
import java.util.Objects;

/**
 * @author Mikhail Reyngardt 23.04.2022
 */
public class CsvDaoVisitor extends ElementScanner9<Void, Void> {

    private final CodeBlock.Builder initCsvDao = CodeBlock.builder();
    private final CodeBlock.Builder commitMethod = CodeBlock.builder();
    private final Trees mTrees;
    private final Messager messager;
    private final Filer mFiler;
    private final TypeElement mOriginElement;
    private final TreeMaker mTreeMaker;
    private final Names mNames;
    private final ResourcesManager resourcesManager;
    private final ClassTypeManager classTypeManager = new ClassTypeManager();
    private final FieldSpec.Builder csvDaoReaderField = FieldSpec.builder(CsvDataReader.class, "dataReader").addModifiers(Modifier.PRIVATE);
    private final FieldSpec.Builder csvDaoWriterField = FieldSpec.builder(CsvDataWriter.class, "dataWriter").addModifiers(Modifier.PRIVATE);

    public CsvDaoVisitor(ProcessingEnvironment environment, TypeElement typeElement) {
        super();
        final JavacProcessingEnvironment javacProcessingEnvironment = ((JavacProcessingEnvironment) jbUnwrap(environment));
        mTrees = Trees.instance(javacProcessingEnvironment);
        messager = environment.getMessager();
        mFiler = javacProcessingEnvironment.getFiler();
        resourcesManager = new ResourcesManager(this.mFiler);
        classTypeManager.setEnclosingType(typeElement.asType());
        mOriginElement = typeElement;
        mTreeMaker = TreeMaker.instance(javacProcessingEnvironment.getContext());
        mNames = Names.instance(javacProcessingEnvironment.getContext());
    }

    @Override
    public Void visitVariable(VariableElement field, Void aVoid) {
        ((JCTree) mTrees.getTree(field)).accept(new TreeTranslator() {
            @Override
            public void visitVarDef(JCTree.JCVariableDecl jcVariableDecl) {
                super.visitVarDef(jcVariableDecl);
                jcVariableDecl.mods.flags &= ~Flags.PRIVATE;
            }
        });
        classTypeManager.setFiledType(field.asType());
        final CsvDao csvDataInit = field.getAnnotation(CsvDao.class);
        String file = csvDataInit.file();
        Objects.requireNonNull(file);
        String pathToFile = getFilePathFromStandardLocations(file);

        csvDaoReaderField
                .initializer("new $T<>($S,$T.class)", CsvDataReader.class, pathToFile, classTypeManager.getEntityClassName()).build();
        csvDaoWriterField
                .initializer("new $T<>($S,$T.class)", CsvDataWriter.class, pathToFile, classTypeManager.getEntityClassName()).build();

        initCsvDao.addStatement("$T data = dataReader.getData()", classTypeManager.getFieldTypeName())
                .beginControlFlow("if (data != null)")
                .addStatement("(($T) this).$L = data", ClassName.get(mOriginElement),
                        field.getSimpleName())
                .endControlFlow()
                .beginControlFlow("else")
                .addStatement("throw new NullPointerException()")
                .endControlFlow();

        commitMethod.addStatement("dataWriter.writeListOfCsvBeanToFile((($T) this).$L)", ClassName.get(mOriginElement),
                field.getSimpleName());

        return super.visitVariable(field, aVoid);
    }

    public void brewJava() {
        final TypeSpec typeSpec = TypeSpec.classBuilder(mOriginElement.getSimpleName() + "$$Proxy")
                .addModifiers(Modifier.ABSTRACT)
                .addOriginatingElement(mOriginElement)
                .addField(csvDaoReaderField.build())
                .addField(csvDaoWriterField.build())
                .addInitializerBlock(initCsvDao.build())
                .addMethod(MethodSpec.methodBuilder("commit")
                        .addModifiers(Modifier.PUBLIC)
                        .addCode(commitMethod.build())
                        .build())
                .build();
        final JavaFile javaFile = JavaFile.builder(mOriginElement.getEnclosingElement().toString(), typeSpec)
                .addFileComment("Generated by CsvDaoProcessor processor, do not modify")
                .build();
        try {
            final JavaFileObject sourceFile = mFiler.createSourceFile(
                    javaFile.packageName + "." + typeSpec.name, mOriginElement);
            try (final Writer writer = new BufferedWriter(sourceFile.openWriter())) {
                javaFile.writeTo(writer);
            }
            JCTree.JCExpression selector = mTreeMaker.Ident(mNames.fromString(javaFile.packageName));
            selector = mTreeMaker.Select(selector, mNames.fromString(typeSpec.name));
            ((JCTree.JCClassDecl) mTrees.getTree(mOriginElement)).extending = selector;
        } catch (IOException e) {
            messager.printMessage(Diagnostic.Kind.ERROR, e.getMessage(), mOriginElement);
        }
    }


    private String getFilePathFromStandardLocations(String file) {
        try {
            return resourcesManager.getFilePath(file);
        } catch (ResourcesManagerException e) {
            messager.printMessage(Diagnostic.Kind.ERROR, e.getMessage(), mOriginElement);
        }
        return null;
    }

    private <T> T jbUnwrap(T wrapper) {
        T unwrapped = null;
        try {
            final Class<?> apiWrappers = wrapper.getClass().getClassLoader().loadClass("org.jetbrains.jps.javac.APIWrappers");
            final Method unwrapMethod = apiWrappers.getDeclaredMethod("unwrap", Class.class, Object.class);
            unwrapped = ((Class<? extends T>) ProcessingEnvironment.class).cast(unwrapMethod.invoke(null, ProcessingEnvironment.class, wrapper));
        } catch (Throwable ignored) {
        }
        return unwrapped != null ? unwrapped : wrapper;
    }
}
