package academy.reyngardt.annotation.processor;

import com.squareup.javapoet.ClassName;
import com.squareup.javapoet.ParameterizedTypeName;
import com.squareup.javapoet.TypeName;
import com.squareup.javapoet.TypeSpec;
import com.squareup.javapoet.CodeBlock;
import com.squareup.javapoet.JavaFile;
import com.sun.source.util.Trees;
import com.sun.tools.javac.code.Flags;
import com.sun.tools.javac.processing.JavacProcessingEnvironment;
import com.sun.tools.javac.tree.JCTree;
import com.sun.tools.javac.tree.TreeMaker;
import com.sun.tools.javac.tree.TreeTranslator;
import com.sun.tools.javac.util.Names;

import javax.annotation.processing.Filer;
import javax.annotation.processing.Messager;
import javax.annotation.processing.ProcessingEnvironment;
import javax.lang.model.element.Modifier;
import javax.lang.model.element.TypeElement;
import javax.lang.model.element.VariableElement;
import javax.lang.model.type.TypeMirror;
import javax.lang.model.util.ElementScanner9;
import javax.tools.Diagnostic;
import javax.tools.JavaFileObject;
import javax.tools.StandardLocation;
import java.io.BufferedWriter;
import java.io.File;
import java.io.IOException;
import java.io.Writer;
import java.lang.reflect.Method;
import java.net.URL;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;

/**
 * @author Mikhail Reyngardt 23.04.2022
 */
public class CsvDataInitVisitor extends ElementScanner9<Void, Void> {

    private final CodeBlock.Builder initCsvDao = CodeBlock.builder();

    private final Trees mTrees;

    private final Messager messager;

    private final Filer mFiler;

    private final TypeElement mOriginElement;

    private final TreeMaker mTreeMaker;

    private final Names mNames;

    public CsvDataInitVisitor(ProcessingEnvironment environment, TypeElement typeElement) {
        super();
        final JavacProcessingEnvironment javacProcessingEnvironment = ((JavacProcessingEnvironment) jbUnwrap(environment));
        mTrees = Trees.instance(javacProcessingEnvironment);
        messager = environment.getMessager();
        mFiler = javacProcessingEnvironment.getFiler();
        mOriginElement = typeElement;
        mTreeMaker = TreeMaker.instance(javacProcessingEnvironment.getContext());
        mNames = Names.instance(javacProcessingEnvironment.getContext());
    }

    @Override
    public Void visitVariable(VariableElement field, Void aVoid) {
        ((JCTree) mTrees.getTree(field)).accept(new TreeTranslator() {
            @Override
            public void visitVarDef(JCTree.JCVariableDecl jcVariableDecl) {
                super.visitVarDef(jcVariableDecl);
                jcVariableDecl.mods.flags &= ~Flags.PRIVATE;
            }
        });
        final CsvDataInit csvDataInit = field.getAnnotation(CsvDataInit.class);
        String file = csvDataInit.file();
        Objects.requireNonNull(file);
        List<ClassName> annotatedFieldTypeNameList = getAnnotatedFieldClassName(field.asType());
        Objects.requireNonNull(annotatedFieldTypeNameList);
        TypeName listOfAnnotatedClass = ParameterizedTypeName.get(annotatedFieldTypeNameList.get(0), annotatedFieldTypeNameList.get(1));
        TypeName csvDataReaderOfAnnotatedClass = ParameterizedTypeName.get(ClassName.get(CsvDataReader.class), annotatedFieldTypeNameList.get(1));
        String pathToFile = getFilePath(file);
        initCsvDao.addStatement("$T dataReader = new $T<>($S,$T.class)", csvDataReaderOfAnnotatedClass, CsvDataReader.class, pathToFile, annotatedFieldTypeNameList.get(1))
                .addStatement("$T data = dataReader.getData()", listOfAnnotatedClass)
                .beginControlFlow("if (data != null)")
                .addStatement("(($T) this).$L = data", ClassName.get(mOriginElement),
                        field.getSimpleName())
                .endControlFlow()
                .beginControlFlow("else")
                .addStatement("throw new NullPointerException()")
                .endControlFlow();

        return super.visitVariable(field, aVoid);
    }

    public void brewJava() {
        final TypeSpec typeSpec = TypeSpec.classBuilder(mOriginElement.getSimpleName() + "$$Proxy")
                .addModifiers(Modifier.ABSTRACT)
                .addOriginatingElement(mOriginElement)
                .addInitializerBlock(initCsvDao.build())
                .build();
        final JavaFile javaFile = JavaFile.builder(mOriginElement.getEnclosingElement().toString(), typeSpec)
                .addFileComment("Generated by CsvDataInitProcessor processor, do not modify")
                .build();
        try {
            final JavaFileObject sourceFile = mFiler.createSourceFile(
                    javaFile.packageName + "." + typeSpec.name, mOriginElement);
            try (final Writer writer = new BufferedWriter(sourceFile.openWriter())) {
                javaFile.writeTo(writer);
            }
            JCTree.JCExpression selector = mTreeMaker.Ident(mNames.fromString(javaFile.packageName));
            selector = mTreeMaker.Select(selector, mNames.fromString(typeSpec.name));
            ((JCTree.JCClassDecl) mTrees.getTree(mOriginElement)).extending = selector;
        } catch (IOException e) {
            messager.printMessage(Diagnostic.Kind.ERROR, e.getMessage(), mOriginElement);
        }
    }

    private List<ClassName> getAnnotatedFieldClassName(TypeMirror type) {
        String[] array = type.toString().split("<", 0);
        if (array.length > 1) {
            array[1] = array[1].replace(">", "");
            List<ClassName> res = new ArrayList<>();
            List<String> firstType = getSplitsClassName(array[0]);
            List<String> secondType = getSplitsClassName(array[1]);
            res.add(ClassName.get(firstType.get(0), firstType.get(1)));
            res.add(ClassName.get(secondType.get(0), secondType.get(1)));
            return res;
        }
        return null;
    }

    private List<String> getSplitsClassName(String name) {
        String[] value = name.split("\\.");
        StringBuilder packageName = new StringBuilder();
        StringBuilder simpleName = new StringBuilder();
        List<String> res = new ArrayList<>();
        for (int i = 0; i < value.length - 1; i++) {
            packageName.append(value[i]);
            if (i < value.length - 2) {
                packageName.append(".");
            }
        }
        simpleName.append(value[value.length - 1]);
        res.add(packageName.toString());
        res.add(simpleName.toString());
        return res;
    }

    private String getFilePath(String file) {
        try {
            URL resource = mFiler.getResource(StandardLocation.CLASS_OUTPUT, "", file).toUri().toURL();
            return new File(resource.getFile()).toPath().toString();
        } catch (IOException ioException) {
            ioException.printStackTrace();
        }
        return null;
    }


    private <T> T jbUnwrap(T wrapper) {
        T unwrapped = null;
        try {
            final Class<?> apiWrappers = wrapper.getClass().getClassLoader().loadClass("org.jetbrains.jps.javac.APIWrappers");
            final Method unwrapMethod = apiWrappers.getDeclaredMethod("unwrap", Class.class, Object.class);
            unwrapped = ((Class<? extends T>) ProcessingEnvironment.class).cast(unwrapMethod.invoke(null, ProcessingEnvironment.class, wrapper));
        } catch (Throwable ignored) {
        }
        return unwrapped != null ? unwrapped : wrapper;
    }
}
